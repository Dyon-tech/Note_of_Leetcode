## 原题链接食用

[1051-高度检查器](https://leetcode-cn.com/problems/height-checker/)

## 题目描述

> 学校在拍年度纪念照时，一般要求学生按照**非递减**的高度顺序排列。
>
> 请你返回能让所有学生以**非递减**高度排列的最小必要移动人数。
>
> 注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。
>
> **示例：**
>
> ```
> 输入：heights = [1,1,4,2,1,3]
> 输出：3 
> 解释：
> 当前数组：[1,1,4,2,1,3]
> 目标数组：[1,1,1,2,3,4]
> 在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。
> 在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。
> 在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。
> ```
>
> **示例2：**
>
> ```
> 输入：heights = [5,1,2,3,4]
> 输出：5
> ```
>
> **示例3：**
>
> ```
> 输入：heights = [1,2,3,4,5]
> 输出：0
> ```
>
> **提示：**
>
> ```
> 1 <= heights.length <= 100
> 1 <= heights[i] <= 100
> ```
>
> 



## 知识点

排序知识，更确切的说是桶排序和计数排序的思想。

但个人觉得这道题考察的更多是理解题意。题目本质其实就是对比序列排序前后在对应索引上数值不同的个数。被LeetCode描述的挺绕的。

## 解题思路

- 从示例中看懂了题目的意思后，关键就在于排序，以及排序后的比较。
- 最简单的办法就是直接调用Java的sort()来排序，然后for循环比较。
- 但根据提示中的信息，可以看出本题的数据长度和数据范围都是一个不大的有限空间，所以如果对排序比较熟悉的话，应该可以想到用计数排序/桶排序来实现，两者都是能达到O(n)的排序算法。
- 简单的采用计数/桶排序后，对桶进行遍历，一一比较桶中的元素和原序列的数值即可。

## 关键点

- 桶排序/计数排序

## 代码

```java
class Solution {
    public int heightChecker(int[] heights) {
        int[] count = new int[101];//开101个空间，方便对原序列的遍历
        int ans = 0;
        
        for(int num : heights){
            count[num]++;
        }
        
        int j = 0;//用于遍历heights
        
        for(int i = 1; i <= 100; i++){
            while(count[i] > 0){
                if(heights[j] != i){
                    ans++;
                }
                count[i]--;
                j++;
            }
        }
        return ans;
    }
}
```

#### 这道题的话，因为heights.length <= 100,所以对空间和时间复杂度的分析就不是特别必要了。